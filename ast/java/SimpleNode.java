/* Generated By:JJTree: Do not edit this line. SimpleNode.java */
package softtest.ast.java;

import org.jaxen.BaseXPath;
import org.jaxen.JaxenException;
import org.jaxen.XPath;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.ParserConfigurationException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
//added by xqing
import softtest.ccd.java.Statement;
import softtest.cfg.java.*;
import softtest.jaxen.java.Attribute;
import softtest.jaxen.java.DocumentNavigator;

import java.util.LinkedList;
import softtest.symboltable.java.*;
import softtest.symboltable.java.Scope;
import softtest.symboltable.java.VariableNameDeclaration;

public abstract class SimpleNode implements Node {

    protected Node parent;
    protected Node[] children;
    protected int id;
    protected JavaParser parser;
    private String image;
    protected int beginLine = -1;
    protected int endLine;
    protected int beginColumn = -1;
    protected int endColumn;
    private Scope scope;
    
    //private final static Map Tokens = new HashMap();
    //private int   kindId;// 标识具体的语法树节点的类别，如ASTName等
    /**	这个hashCode用于重复代码检测中, 不可用于两个本类对象之间的比较 **/
    private int   hashCode;//		[ LW ]
    
    /**  用于重复代码检测中,为了得到语句节点在语句串中的索引  **/
    private Statement stmt;	//      [ LW ]

    public SimpleNode(int i) {
        id = i;
    }

    public SimpleNode(JavaParser p, int i) {
        this(i);
        parser = p;
    }

    public void setScope(Scope scope) {
        this.scope = scope;
    }

    public Scope getScope() {
        if (scope == null) {
            return ((SimpleNode) parent).getScope();
        }
        return scope;
    }

    public int getBeginLine() {
        return beginLine;
    }

    // A label is a more visually useful image, e.g.
    // int[[ for a primary suffix that's a 2D array of ints
    // this is used only by the Designer to show nodes more helpfully
    public String getLabel() {
        return null;        
    }

    public boolean hasImageEqualTo(String arg) {
    	return image != null && image.equals(arg);
    }
    
    public void testingOnly__setBeginLine(int i) {
        this.beginLine = i;
    }

    public void testingOnly__setBeginColumn(int i) {
        this.beginColumn = i;
    }

    public int getBeginColumn() {
        if (beginColumn != -1) {
            return beginColumn;
        } else {
            if ((children != null) && (children.length > 0)) {
                return ((SimpleNode) children[0]).getBeginColumn();
            } else {
                throw new RuntimeException("Unable to determine begining line of Node.");
            }
        }
    }

    public String getImage() {
        return image;
    }

    public void setImage(String image) {
        this.image = image;
    }

    public int getEndLine() {
        return endLine;
    }

    public int getEndColumn() {
        return endColumn;
    }

    public Node getNthParent(int n) {
        Node result = null;
        for (int i = 0; i < n; i++) {
            if (result == null) {
                result = this.jjtGetParent();
            } else {
                result = result.jjtGetParent();
            }
        }
        return result;
    }

    /**
     * Traverses up the tree to find the first parent instance of type parentType
     *
     * @param parentType class which you want to find.
     * @return Node of type parentType.  Returns null if none found.
     */
    public Node getFirstParentOfType(Class parentType) {
        Node parentNode = jjtGetParent();
        while (parentNode != null && parentNode.getClass() != parentType) {
            parentNode = parentNode.jjtGetParent();
        }
        return parentNode;
    }

    /**
     * Traverses up the tree to find all of the parent instances of type parentType
     *
     * @param parentType classes which you want to find.
     * @return List of parentType instances found.
     */
    public List getParentsOfType(Class parentType) {
        List parents = new ArrayList();
        Node parentNode = jjtGetParent();
        while (parentNode != null) {
            if (parentNode.getClass() == parentType) {
                parents.add(parentNode);
            }
            parentNode = parentNode.jjtGetParent();
        }
        return parents;
    }

    public List findChildrenOfType(Class targetType) {
        List list = new ArrayList();
        findChildrenOfType(targetType, list);
        return list;
    }

    public void findChildrenOfType(Class targetType, List results) {
        findChildrenOfType(this, targetType, results, true);
    }

    public void findChildrenOfType(Class targetType, List results, boolean descendIntoNestedClasses) {
        this.findChildrenOfType(this, targetType, results, descendIntoNestedClasses);
    }

    private void findChildrenOfType(Node node, Class targetType, List results, boolean descendIntoNestedClasses) {
        if (node.getClass().equals(targetType)) {
            results.add(node);
        }

        if (!descendIntoNestedClasses) {
            if (node instanceof ASTClassOrInterfaceDeclaration && ((ASTClassOrInterfaceDeclaration) node).isNested()) {
                return;
            }

            if (node instanceof ASTClassOrInterfaceBodyDeclaration && ((ASTClassOrInterfaceBodyDeclaration) node).isAnonymousInnerClass()) {
                return;
            }
        }

        for (int i = 0; i < node.jjtGetNumChildren(); i++) {
            Node child = node.jjtGetChild(i);
            if (child.jjtGetNumChildren() > 0) {
                findChildrenOfType(child, targetType, results, descendIntoNestedClasses);
            } else {
                if (child.getClass().equals(targetType)) {
                    results.add(child);
                }
            }
        }
    }

    public void jjtSetParent(Node n) {
        parent = n;
    }

    public Node jjtGetParent() {
        return parent;
    }

    public void jjtAddChild(Node n, int i) {
        if (children == null) {
            children = new Node[i + 1];
        } else if (i >= children.length) {
            Node c[] = new Node[i + 1];
            System.arraycopy(children, 0, c, 0, children.length);
            children = c;
        }
        children[i] = n;
    }

    public Node jjtGetChild(int i) {
        return children[i];
    }

    public int jjtGetNumChildren() {
        return (children == null) ? 0 : children.length;
    }

    public String toString(String prefix) {
        return prefix + toString();
    }

    public Document asXml() {
        try {
            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            DocumentBuilder db = dbf.newDocumentBuilder();
            Document document = db.newDocument();
            appendElement(document);
            return document;
        } catch (ParserConfigurationException pce) {
            throw new RuntimeException(pce);
        }
    }

    protected void appendElement(org.w3c.dom.Node parentNode) {
        DocumentNavigator docNav = new DocumentNavigator();
        Document ownerDocument = parentNode.getOwnerDocument();
        if (ownerDocument == null) {
            //If the parentNode is a Document itself, it's ownerDocument is null
            ownerDocument = (Document) parentNode;
        }
        String elementName = docNav.getElementName(this);
        Element element = ownerDocument.createElement(elementName);
        parentNode.appendChild(element);
        for (Iterator iter = docNav.getAttributeAxisIterator(this); iter.hasNext();) {
            Attribute attr = (Attribute) iter.next();
            element.setAttribute(attr.getName(), attr.getValue());
        }
        for (Iterator iter = docNav.getChildAxisIterator(this); iter.hasNext();) {
            SimpleNode child = (SimpleNode) iter.next();
            child.appendElement(element);
        }
    }

    /* Override this method if you want to customize how the node dumps
       out its children. */
    public void dump(String prefix) {
        System.out.println(toString(prefix) + (image == null ? "" : ":" + image));
        dumpChildren(prefix);
    }

    protected void dumpChildren(String prefix) {
        if (children != null) {
            for (int i = 0; i < children.length; ++i) {
                SimpleNode n = (SimpleNode) children[i];
                if (n != null) {
                    n.dump(prefix + " ");
                }
            }
        }
    }


    /**
     * Traverses down the tree to find the first child instance of type childType
     *
     * @param childType class which you want to find.
     * @return Node of type childType.  Returns <code>null</code> if none found.
     */
    public Node getFirstChildOfType(Class childType) {
        return getFirstChildOfType(childType, this);
    }

    private Node getFirstChildOfType(Class childType, Node node) {
        for (int i = 0; i < node.jjtGetNumChildren(); i++) {
            Node n = node.jjtGetChild(i);
            if (n != null) {
                if (n.getClass().equals(childType))
                    return n;
                Node n2 = getFirstChildOfType(childType, n);
                if (n2 != null)
                    return n2;
            }
        }
        return null;
    }

    /**
     * Finds if this node contains a child of the given type.
     * This is an utility method that uses {@link #findChildrenOfType(Class)}
     *
     * @param type the node type to search
     * @return <code>true</code> if there is at lease on child of the given type and <code>false</code> in any other case
     */
    public final boolean containsChildOfType(Class type) {
        return !findChildrenOfType(type).isEmpty();
    }

    public List findChildNodesWithXPath(String xpathString) throws JaxenException {
        return new BaseXPath(xpathString, new DocumentNavigator()).selectNodes(this);
    }
    
    // added by xqing
	/** 控制流图节点列表，一个语法树节点可能对应多个控制流节点，请参看ControlFlowVisitor代码，通常第一个节点是主要头节点 */
	private List<VexNode> vexlist = null;
	
	/** 在当前节点上查找xpath，返回选中的节点列表 */
	public List findXpath(String xPath){
		List evaluationResults = null;
		try {
			XPath xpath = new BaseXPath(xPath, new DocumentNavigator());
			evaluationResults = xpath.selectNodes(this);
		} catch (JaxenException e) {
			if(softtest.config.java.Config.DEBUG){
				e.printStackTrace();
			}
			throw new RuntimeException("xpath error");
		}
		return evaluationResults;
	}

	/** 添加控制流节点*/
	public void setVexNode(VexNode vex) {
		if (vexlist == null) {
			vexlist = new LinkedList<VexNode>();
		}
		vexlist.add(vex);
	}
    
	/** 获得控制流节点列表*/
    public List<VexNode> getVexNode(){
    	return vexlist;
    }
    
    /**获得第一个控制流节点*/
    public VexNode getFirstVexNode(){
    	VexNode vex=null;
    	if(!vexlist.isEmpty()){
    		vex=vexlist.get(0);
    	}
    	return vex;
    }
    
    /**添加字符串，主要用于处理java表达式，请参看java.jjt*/
    void addImage(String image){
    	if(this.image==null){
    		this.image=image;
    	}
    	else{
    		this.image=this.image+"#"+image;
    	}
    }

    /** 获得类型为type的直接孩子列表 */
	public final List findDirectChildOfType(Class type) {
		List results = new ArrayList();
		for (int i = 0; i < jjtGetNumChildren(); i++) {
			Node child = jjtGetChild(i);
			if (child.getClass().equals(type)) {
				results.add(child);
			}
		}
		return results;
	}
	
	/**获得当前的控制流节点列表，通常为当前正在处理的语法树或其祖先对应的控制流节点*/
	 public List<VexNode> getCurrentVexList() {
		if(vexlist!=null&&!vexlist.isEmpty()){
			return vexlist;
		}
		if(parent!=null){
			return ((SimpleNode) parent).getCurrentVexList();
		}
		return null;
	}
	 
	 public VexNode getCurrentVexNode(){
		 List<VexNode> list=getCurrentVexList();
		 if(list!=null&&!list.isEmpty()){
			 return list.get(0);
		 }
		 return null;
	 }
    
	/**获得变量v的当前域,如果该与当前控制流节点无关则返回初始化域 */
	public Object findCurrentDomain(VariableNameDeclaration v){
		Object domain=null;
		VexNode vex=getCurrentVexNode();
		if(vex!=null){
			domain=vex.getDomainWithoutNull(v);
		}else{
			domain=v.getDomain();
		}
		//System.out.println(domain);
		return domain;
	}
	
	/**获得变量v的当前域,如果该与当前控制流节点无关则返回初始化域 */
	public Object findCurrentDomain(VariableNameDeclaration v, VexNode vex){
		Object domain=null;
		if(vex!=null){
			domain=vex.getDomainWithoutNull(v);
		}else{
			domain=v.getDomain();
		}
		//System.out.println(domain);
		return domain;
	}
	
	/** 获得第一个类型为targetType的子孙节点 */
	public Object getFirstChildrenOfType(Class targetType) {
        List list = findChildrenOfType(targetType);
        Object target=null;
        if(!list.isEmpty()){
        	target=list.get(0);
        }
        return target;
    }
	
	/** 获得第一个类型为targetType的直接孩子节点 */
	public Object getFirstDirectChildOfType(Class targetType) {
		List list = findDirectChildOfType(targetType);
		Object target = null;
		if (!list.isEmpty()) {
			target = list.get(0);
		}
		return target;
	}
	
	/** 查找第一个parentType的祖先，但是搜索不超过searchend以上，searchend必须为当前节点得祖先 */
	public Node getFirstParentOfType(Class parentType,Node searchend) {
        Node parentNode = jjtGetParent();
        while (parentNode != searchend && parentNode.getClass() != parentType) {
            parentNode = parentNode.jjtGetParent();
        }
        if(parentNode==searchend&&parentNode.getClass() != parentType){
        	return null;
        }
        return parentNode;
    }
	
	/** 获得第类型为targetType的单支子孙节点 */
	public Object getSingleChildofType(Class targetType){
		Object target=null;
		if(getClass().equals(targetType)){
			return this;
		}
		if(jjtGetNumChildren()==1){
			return ((SimpleNode)jjtGetChild(0)).getSingleChildofType(targetType);
		}
		return target;
	}
	
	/** 获得第类型为targetType的单支子孙节点,ASTCastExpression可以有两个孩子 */
	public Object getSingleOrCastChildofType(Class targetType){
		Object target=null;
		if(getClass().equals(targetType)){
			return this;
		}
		if(jjtGetNumChildren()==1){
			return ((SimpleNode)jjtGetChild(0)).getSingleOrCastChildofType(targetType);
		}
		if(this instanceof ASTCastExpression){
			return ((SimpleNode)jjtGetChild(1)).getSingleOrCastChildofType(targetType);
		}
		return target;
	}
	
	/** 获得第一个类型为targetType的单支祖先节点 */
	public Object getSingleParentofType(Class targetType){
		Node parentNode = jjtGetParent();
        while (parentNode != null && parentNode.getClass() != targetType && parentNode.jjtGetNumChildren()==1) {
            parentNode = parentNode.jjtGetParent();
        }
        if(parentNode!=null&&parentNode.jjtGetNumChildren()==1&&parentNode.getClass() == targetType){
        	return parentNode;
        }else{
        	return null;
        }
	}
	
    /**
     * 获得第一个类型为parentTypes数组中元素之一类型的祖先节点
     * @param parentTypes 要查找的可能类型数组
     * @return 第一个类型出现在parentTypes中的祖先节点
     */
    public Node getFirstParentOfTypes(Class[] parentTypes) {
        Node parentNode = jjtGetParent();
        out:while (parentNode != null ) {
        	for(Class type:parentTypes){
        		if(parentNode.getClass() == type){
        			break out;
        		}
        	}
            parentNode = parentNode.jjtGetParent();
        }
        return parentNode;
    }
	
	/** 判断语法树节点parent是否为当前节点自己或祖先 */
	public boolean isSelOrAncestor(SimpleNode ancestor) {
		boolean bret = false;
		SimpleNode parentNode = this;
		while (parentNode != null) {
			if (parentNode == ancestor) {
				bret = true;
				break;
			}
			parentNode = (SimpleNode)parentNode.jjtGetParent();
		}
		return bret;
	}
	
    public String printNode(String filename) {
    	String str;
        str=softtest.database.java.DBAccess.getSouceCode(filename,getBeginLine(), getBeginColumn(), getEndLine(), getEndColumn());
        return str;
    }
    
    public String printNode(String filename, int specifiedLine) {
    	String str;
        str=softtest.database.java.DBAccess.getSouceCode(filename,specifiedLine, 1, specifiedLine, getEndColumn());
        return str;
    }
    
    /** 判断当前节点和node间是否存在局部函数声明节点 ，node为当前节点祖先*/
    public boolean hasLocalMethod(SimpleNode node){
    	SimpleNode current = this;
		while (current != null && current != node) {
			if ((current instanceof ASTConstructorDeclaration)||(current instanceof ASTMethodDeclaration)) {
				return true;
			}
			current = (SimpleNode)current.jjtGetParent();
		}
    	return false;
    }
    
    /** 返回实际能实际计算的节点 */
    public SimpleNode getConcreteNode(){ 	
    	if (this instanceof ASTIfStatement) {
			return (SimpleNode) this.jjtGetChild(0);
		} else if (this instanceof ASTWhileStatement) {
			return (SimpleNode) this.jjtGetChild(0);
		} else if (this instanceof ASTSwitchStatement) {
			return (SimpleNode) this.jjtGetChild(0);
		} else if (this instanceof ASTForStatement) {
			List results = this.findDirectChildOfType(ASTExpression.class);
			if (!results.isEmpty()) {
				return (SimpleNode) results.get(0);
			}else{
				return null;
			}
		} else if (this instanceof ASTSynchronizedStatement) {
			return (SimpleNode) this.jjtGetChild(0);
		} else if (this instanceof ASTTryStatement) {
			return null;
		} else if (this instanceof ASTCatchStatement) {
			return null;
		} else if (this instanceof ASTFinallyStatement) {
			return null;
		} else if (this instanceof ASTDoStatement) {
			return null;
		} else if (this instanceof ASTLabeledStatement){
			return null;
		} /*else if (this instanceof ASTConstructorDeclaration){
			return null;
		} else if (this instanceof ASTMethodDeclaration){
			return null;
		}*/
    	return this;
    }

	public int getHashCode() {
		return hashCode;
	}
	public void setHashCode(int hashCode) {
		this.hashCode = hashCode;
	}

	public int getId() {
		return id;
	}

	
	public Statement getStmt() {
		return stmt;
	}

	public void setStmt(Statement stmt) {
		this.stmt = stmt;
	}
	
	public Node getLastSibling(){
		Node parent = jjtGetParent();
		if(parent!=null){
			int index = -1;
			for(int ret = 0 ;ret < parent.jjtGetNumChildren() ; ++ret){
				if(parent.jjtGetChild(ret)==this){
					index = ret;
					break;
				}
			}
			if (index == 0 || index == -1) {
				return null;
			} else {
				return parent.jjtGetChild(index-1);
			}
		}		
		return null;
	}
	
	public Node getNextSibling(){
		Node parent = jjtGetParent();
		if(parent!=null){
			boolean find=false;
			for(int ret = 0 ;ret < parent.jjtGetNumChildren() ; ++ret){
				if(parent.jjtGetChild(ret)==this){
					find=true;					
				} else if (find) {
					return parent.jjtGetChild(ret);
				}
			}
		}		
		return null;
	}
	
	public Node getPrevSibling(){
		Node parent = jjtGetParent();
		if(parent!=null){
			boolean find=false;
			int ret = 0;
			for(ret =0 ;ret < parent.jjtGetNumChildren() ; ++ret){
				if(parent.jjtGetChild(ret)==this){
					find=true;				
					break;
				} 
			}
			if (find&&ret>0) {
				return parent.jjtGetChild(ret-1);
			}
		}		
		return null;
	}
	
	public int getIndexOfParent(){
		int ret =-1;
		Node parent=jjtGetParent();
		if(parent!=null){
			boolean find=false;
			for(ret = 0 ;ret<parent.jjtGetNumChildren();ret++ ){
				if(parent.jjtGetChild(ret)==this){
					find=true;
					break;
				}
			}
			if(!find){
				ret=-1;
			}
		}
		
		return ret;
	}
}
